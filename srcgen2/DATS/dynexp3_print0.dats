(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2023 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 14 Feb 2023 08:27:19 PM EST
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
#include
"./../HATS/xatsopt_sats.hats"
#include
"./../HATS/xatsopt_dats.hats"
(* ****** ****** *)
#define
ATS_PACKNAME
"ATS3.XANADU.xatsopt-20220500"
(* ****** ****** *)
#staload
_(*?*) = "./lexing0_print0.dats"
(* ****** ****** *)
#staload "./../SATS/lexing0.sats"
(* ****** ****** *)
(*
#staload "./../SATS/staexp0.sats"
#staload "./../SATS/dynexp0.sats"
*)
(* ****** ****** *)
#staload "./../SATS/staexp1.sats"
#staload "./../SATS/dynexp1.sats"
(* ****** ****** *)
#staload "./../SATS/staexp2.sats"
#staload "./../SATS/dynexp2.sats"
(* ****** ****** *)
#staload "./../SATS/dynexp3.sats"
(* ****** ****** *)
#symload lctn with d3pat_get_lctn
#symload node with d3pat_get_node
#symload styp with d3pat_get_styp
(* ****** ****** *)
#symload lctn with d3exp_get_lctn
#symload node with d3exp_get_node
#symload styp with d3exp_get_styp
(* ****** ****** *)
#symload lctn with f3arg_get_lctn
#symload node with f3arg_get_node
(* ****** ****** *)
#symload lctn with d3gua_get_lctn
#symload lctn with d3gpt_get_lctn
#symload lctn with d3cls_get_lctn
#symload node with d3gua_get_node
#symload node with d3gpt_get_node
#symload node with d3cls_get_node
(* ****** ****** *)
#symload lctn with d3ecl_get_lctn
#symload node with d3ecl_get_node
(* ****** ****** *)
#symload stmp with timpl_get_stmp
#symload node with timpl_get_node
(* ****** ****** *)

#implfun
d3pat_fprint
(out, d3p0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
d3p0.node() of
//
|D3Pany() =>
prints("D3Pany(",")")
//
|D3Pvar(d2v) =>
prints("D3Pvar(",d2v,")")
//
|D3Pint(tok) =>
prints("D3Pint(",tok,")")
|D3Pbtf(sym) =>
prints("D3Pbtf(",sym,")")
|D3Pchr(tok) =>
prints("D3Pchr(",tok,")")
|D3Pstr(tok) =>
prints("D3Pstr(",tok,")")
//
|D3Pcon(d2c) =>
prints("D3Pcon(",d2c,")")
//
|
D3Pbang(d3p1) =>
prints("D3Pbang(",d3p1,")")
|
D3Pflat(d3p1) =>
prints("D3Pflat(",d3p1,")")
|
D3Pfree(d3p1) =>
prints("D3Pfree(",d3p1,")")
//
|
D3Psapp
(d3f0, s2vs) =>
prints
("D3Psapp(",d3f0,";",s2vs,")")
|
D3Psapq
(d3f0, s2as) =>
prints
("D3Psapq(",d3f0,";",s2as,")")
//
|
D3Ptapq
(d3p1, tjas) =>
prints("D3Ptapq(",d3p1,";",tjas,")")
//
|
D3Pdap1(d3f0) =>
(
  prints("D3Pdap1(", d3f0, ")"))
//
|
D3Pdapp
(d3f0, npf1, d3ps) =>
(
print("D3Pdapp(");
prints(d3f0,";",npf1,";",d3ps,")") )
//
|
D3Ptup0(npf1, d3ps) =>
prints("D3Ptup0(",npf1,";",d3ps,")")
|
D3Ptup1
( tknd, npf1, d3ps ) =>
( print("D3Ptup1(")
; prints(tknd,";",npf1,";",d3ps,")") )
|
D3Prcd2
( tknd, npf1, ldps ) =>
( print("D3Prcd2(")
; prints(tknd,";",npf1,";",ldps,")") )
//
(* ****** ****** *)
//
|
D3Pannot
(d3p1, s1e2, s2e2) =>
prints("D3Pannot(",d3p1,";",s1e2,";",s2e2,")")
//
(* ****** ****** *)
//
|D3Pt2pck
( d3p1 , t2p2 ) =>
(
  prints("D3Pt2pck(",d3p1,";",t2p2,")"))
//
(* ****** ****** *)
//
|D3Pnone0() => prints( "D3Pnone0(",")" )
|D3Pnone1(d2p1) => prints("D3Pnone1(",d2p1,")")
|D3Pnone2(d3p1) => prints("D3Pnone2(",d3p1,")")
//
(* ****** ****** *)
//
|D3Perrck // HX: generated by [tread23]
(lvl1(*err-level*),d3p2) => prints("D3Perrck(",lvl1,";",d3p2,")")
//
end (*let*) // end of [d3pat_fprint(out, d3p0)]

(* ****** ****** *)

#implfun
d3exp_fprint
(out, d3e0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
d3e0.node() of
//
(* ****** ****** *)
//
|D3Eint(tok) =>
prints("D3Eint(",tok,")")
|D3Ebtf(sym) =>
prints("D3Ebtf(",sym,")")
|D3Echr(tok) =>
prints("D3Echr(",tok,")")
|D3Eflt(tok) =>
prints("D3Eflt(",tok,")")
|D3Estr(tok) =>
prints("D3Estr(",tok,")")
//
(* ****** ****** *)
//
|D3Ei00(int) =>
prints("D3Ei00(",int,")")
|D3Eb00(btf) =>
prints("D3Eb00(",btf,")")
|D3Ec00(chr) =>
prints("D3Ec00(",chr,")")
|D3Ef00(flt) =>
prints("D3Ef00(",flt,")")
|D3Es00(str) =>
prints("D3Es00(",str,")")
//
(* ****** ****** *)
//
|D3Etop(sym) =>
prints("D3Etop(", sym, ")")
//
(* ****** ****** *)
//
|D3Evar(d2v) =>
prints("D3Evar(", d2v, ")")
//
(* ****** ****** *)
//
|D3Econ(d2c) =>
prints("D3Econ(", d2c, ")")
|D3Ecst(d2c) =>
prints("D3Ecst(", d2c, ")")
//
(* ****** ****** *)
//
|
D3Etimp
(d2e1, timp) =>
prints("D3Etimp(",d2e1,";",timp,")")
//
(* ****** ****** *)
//
|
D3Esapp
(d3e1, s2es) =>
prints("D3Esapp(",d3e1,";",s2es,")")
|
D3Esapq
(d3e1, t2ps) =>
prints("D3Esapq(",d3e1,";",t2ps,")")
//
(* ****** ****** *)
//
|
D3Etapp
(d3e1, s2es) =>
prints("D3Etapp(",d3e1,";",s2es,")")
|
D3Etapq
(d3e1, tjas) =>
prints("D3Etapq(",d3e1,";",tjas,")")
//
(* ****** ****** *)
//
|
D3Edap0(d3f0) =>
prints( "D3Edap0(", d3f0, ")" )
|
D3Edapp
(d3f0,npf1,d3es) =>
( print("D3Edapp(")
; prints(d3f0,";",npf1,";",d3es,")"))
//
(* ****** ****** *)
//
|
D3Epcon
(tknd,dlab,dtup) =>
( print("D3Epcon(")
; prints(tknd,";",dlab,";",dtup,")"))
|
D3Eproj
(tknd,dlab,dtup) =>
( print("D3Eproj(")
; prints(tknd,";",dlab,";",dtup,")"))
//
(* ****** ****** *)
//
|
D3Elet0
(dcls, d3e1) =>
(
prints("D3Elet0(",dcls,";",d3e1,")"))
//
(* ****** ****** *)
//
|D3Eift0
(d3e1,dthn,dels) =>
( print("D3Eift0(")
; prints(d3e1,";",dthn,";",dels,")"))
//
|
D3Ecas0
(tknd,d3e1,dcls) =>
( print("D3Ecas0(");
  prints(tknd,";",d3e1,";",dcls,")"))
//
(* ****** ****** *)
//
|D3Eseqn
(d3es, d3e1) =>
(
prints("D3Eseqn(",d3es,";",d3e1,")"))
//
(* ****** ****** *)
//
|D3Etup0
(npf1, d3es) =>
(
prints("D3Etup0(",npf1,";",d3es,")"))
|
D3Etup1
(tknd,npf1,d3es) =>
( print("D3Etup1(")
; prints(tknd,";",npf1,";",d3es,")"))
|
D3Ercd2
(tknd,npf1,ldes) =>
( print("D3Ercd2(")
; prints(tknd,";",npf1,";",ldes,")"))
//
(* ****** ****** *)
//
|
D3Elam0
(tknd,f3as
,sres,arrw,body) =>
(
prints
("D3Elam0(",tknd,";");
prints
(f3as,";",sres,";",arrw,";",body,")"))
//
|
D3Efix0
(tknd,fid0,f3as
,sres,arrw,body) =>
(
prints
("D3Efix0(",tknd,";",fid0,";");
prints
(f3as,";",sres,";",arrw,";",body,")"))
//
(* ****** ****** *)
//
|
D3Etry0
( tknd
, d3e1, dcls) =>
(
print("D3Etry0(");
prints( tknd, ";",d3e1, ";",dcls,")"))
//
(* ****** ****** *)
//
|D3Eaddr
(   d3e1   ) =>
prints("D3Eaddr(",d3e1,")") // left-val
|D3Eview
(   d3e1   ) =>
prints("D3Eview(",d3e1,")") // left-val
|D3Eflat
(   d3e1   ) =>
prints("D3Eflat(",d3e1,")") // left-val
//
(* ****** ****** *)
//
|D3Eeval
(   d3e1   ) =>
prints("D3Eeval(",d3e1,")") // eval-fun
//
(* ****** ****** *)
//
|D3Efold
(   d3e1   ) =>
prints("D3Efold(",d3e1,")") // open-con
|D3Efree
(   d3e1   ) =>
prints("D3Efree(",d3e1,")") // free-con
//
(* ****** ****** *)
//
|D3Edp2tr
(   d3e1   ) =>
prints("D3Edp2tr(",d3e1,")") // de-p2tr
//
|D3Edl0az
(   d3e1   ) =>
prints("D3Edl0az(",d3e1,")") // de-l0az
|D3Edl1az
(   d3e1   ) =>
prints("D3Edl1az(",d3e1,")") // de-l1az
//
(* ****** ****** *)
//
|
D3Ewhere
(d3e1, dcls) =>
(
 prints("D3Ewhere(",d3e1,";",dcls,")"))
//
(* ****** ****** *)
//
|
D3Eassgn
(d3el, d3er) =>
(
 prints("D3Eassgn(",d3el,";",d3er,")"))
//
(* ****** ****** *)
//
|
D3Eraise
(tknd, d3e1) =>
(
 prints("D3Eraise(",tknd,";",d3e1,")"))
//
(* ****** ****** *)
//
|
D3El0azy
( dsym, d3e1 ) =>
(
 prints("D3El0azy(",dsym,";",d3e1,")"))
|
D3El1azy
( dsym
, d3e1 , d3es ) =>
(
  print("D3El1azy(")
; prints( dsym, ";",d3e1, ";",d3es,")"))
//
(* ****** ****** *)
//
|D3Eannot
( d3e1
, s1e2 , s2e2 ) =>
(
  print("D3Eannot(")
; prints( d3e1, ";",s1e2, ";",s2e2,")"))
//
(* ****** ****** *)
//
|D3Elabck
( d3e1 , lab2 ) =>
let
val
t2p1 = d3e1.styp() in
(
  print("D3Elabck(")
; prints( d3e1, ";",t2p1, ";",lab2,")"))
endlet // end of [ D3Elabck(d3e1, lab2) ]
//
|D3Et2pck
( d3e1 , t2p2 ) =>
let
val
t2p1 = d3e1.styp() in
(
  print("D3Et2pck(")
; prints( d3e1, ";",t2p1, ";",t2p2,")"))
endlet // end of [ D3Et2pck(d3e1, t2p2) ]
//
(* ****** ****** *)
//
|
D3Eexists
( s2es, d3e1) =>
(
prints("D3Eexists(",s2es,";",d3e1,")") )
//
(* ****** ****** *)
//
|
D3Eextnam
( tknd, gnam) =>
(
prints("D3Eextnam(",tknd,";",gnam,")") )
//
|
D3Esynext
( tknd, gexp) =>
(
prints("D3Esynext(",tknd,";",gexp,")") )
//
(* ****** ****** *)
//
|D3Enone0() => prints( "D3Enone0(", ")" )
|D3Enone1(d2e1) => prints("D3Enone1(", d2e1, ")")
|D3Enone2(d3e1) => prints("D3Enone2(", d3e1, ")")
//
(* ****** ****** *)
//
|
D3Eerrck // HX: generated by [tread23]
(lvl1(*err-level*),d3e2) => prints("D3Eerrck(",lvl1,";",d3e2,")")
//
end (*let*) // end of [d3exp_fprint(out, d3e0)]

(* ****** ****** *)

#implfun
f3arg_fprint
(out, farg) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
farg.node() of
|
F3ARGdapp
(npf1,d3ps) =>
prints
("F3ARGdapp(",npf1,";",d3ps,")")
|
F3ARGsapp
(s2vs,s2ps) =>
prints
("F3ARGsapp(",s2vs,";",s2ps,")")
|
F3ARGmets
(   s2es   ) => prints("F3ARGmets(",s2es,")")
(*
|
F3ARGsapq
(   s2vs   ) => prints("F3ARGsapq(",s2vs,")")
*)
//
end (*let*) // end of [f3arg_fprint(out,farg)]

(* ****** ****** *)
//
#implfun
d3gua_fprint
(out, dgua) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
dgua.node() of
|
D3GUAexp(d3e1) =>
prints("D3GUAexp(",d3e1,")")
|
D3GUAmat(d3e1,d3p2) =>
prints("D3GUAmat(",d3e1,";",d3p2,")")
//
end (*let*) // end of [d3gua_fprint(out,dgua)]
//
(* ****** ****** *)
//
#implfun
d3gpt_fprint
(out, dgpt) =
let
#impltmp
g_print$out<>() = out
in//let
case+
dgpt.node() of
|
D3GPTpat(d3p1) =>
prints("D3GPTpat(",d3p1,")")
|
D3GPTgua(d3p1,d3gs) =>
prints("D3GPTgua(",d3p1,";",d3gs,")")
end (*let*) // end of [d3gpt_fprint(out,dgpt)]
//
#implfun
d3cls_fprint
(out, dcls) =
let
#impltmp
g_print$out<>() = out
in//let
case+
dcls.node() of
|
D3CLSgpt(dgpt) =>
prints("D3CLSgpt(",dgpt,")")
|
D3CLScls(d3g1,d3e2) =>
prints("D3CLScls(",d3g1,";",d3e2,")")
end (*let*) // end of [d3cls_fprint(out,dcls)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#implfun
timpl_fprint
(out, timp) =
let
#implfun
g_print$out<>() = out
in//let
case+
timp.node() of
//
(*
|TIMPLone1
(  dcl1  ) =>
prints("TIMPLone1(", dcl1 ,")")
*)
//
|TIMPLall1
(d2c1, dcls) =>
prints("TIMPLall1(",d2c1,";",dcls,")")
//
|TIMPLallx
(d2c1, dcls) =>
prints("TIMPLallx(",d2c1,";",dcls,")")
//
end (*let*) // end of [timpl_fprint(...)]
//
(* ****** ****** *)
(* ****** ****** *)

#implfun
d3ecl_fprint
(out, dcl0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
dcl0.node() of
//
|D3Cd2ecl(d2cl) =>
prints("D3Cd2ecl(",d2cl,")")
//
|
D3Cstatic(tknd,dcl1) =>
prints("D3Cstatic(",tknd,";",dcl1,")")
|
D3Cextern(tknd,dcl1) =>
prints("D3Cextern(",tknd,";",dcl1,")")
//
|
D3Ctmpsub(svts,dcl1) =>
prints("D3Ctmpsub(",svts,";",dcl1,")")
//
|
D3Clocal0(head, body) =>
prints( "D3Clocal(",head,";",body,")" )
//
|
D3Cabsopen
( tknd , simp ) =>
prints
("D3Cabsopen(",tknd,";",simp,")")
|
D3Cabsimpl
(tknd,simp,sdef) =>
(
print("D3Cabsimpl(");
prints(tknd, ";", simp, ";", sdef, ")")
)
//
|
D3Cinclude
(knd0,tknd
,gsrc,fopt,dopt) =>
(
print("D3Cinclude(");
prints
(knd0,";"
,tknd,";",gsrc,";",fopt,";","...",")"))
//
|
D3Cstaload
(knd0,tknd
,gsrc,fopt,dopt) =>
(
print("D3Cstaload(");
prints
(knd0,";"
,tknd,";",gsrc,";",fopt,";","...",")"))
//
(* ****** ****** *)
//
(*
HX-2024-07-20:
Sat 20 Jul 2024 02:18:49 PM EDT
*)
//
|
D3Cdyninit(tknd,g1e1) =>
(
prints("D3Cdyninit(",tknd,";",g1e1,")"))
|
D3Cextcode(tknd,g1e1) =>
(
prints("D3Cextcode(",tknd,";",g1e1,")"))
//
(* ****** ****** *)
//
|
D3Cvaldclst
(  tknd, d3vs  ) =>
(
prints("D3Cvaldclst(",tknd,";",d3vs,")"))
|
D3Cvardclst
(  tknd, d3vs  ) =>
(
prints("D3Cvardclst(",tknd,";",d3vs,")"))
//
|
D3Cfundclst
(tknd
,tqas,d2cs,d3fs) =>
(
print("D3Cfundclst(");
prints(tknd,";",tqas,";",d2cs,";",d3fs,")"))
//
|
D3Cimplmnt0
(tknd
,stmp
,sqas,tqas
,dqid,tias
,farg,sres,body) =>
(
print("D3Cimplmnt0(");
prints(tknd,";",stmp,";");
prints(sqas,";",tqas,";");
prints(dqid,";",tias,";",farg,";",sres,";",body,")"))
//
|
D3Ctmplocal
(  dtmp, dcls ) =>
(
prints("D3Ctmplocal(",dtmp,";",dcls,")"))
//
|
D3Cimpltmpr(dcl1,t2js) =>
(
prints("D3Cimpltmpr(",dcl1,";",t2js,")"))
//
|D3Cnone0() => prints( "D3Cnone0(", ")" )
|D3Cnone1(d2cl) => prints( "D3Cnone1(",d2cl,")" )
|D3Cnone2(d3cl) => prints( "D3Cnone2(",d3cl,")" )
//
|
D3Cerrck // HX: generated by [tread23]
(lvl1(*err-level*),d3cl) => prints("D3Cerrck(",lvl1,";",d3cl,")")
//
end (*let*) // end of [d3ecl_fprint(out, dcl0)]

(* ****** ****** *)
(* ****** ****** *)

#implfun
d3valdcl_fprint
  (out, dval) = let
//
val dpat =
d3valdcl_get_dpat(dval)
val tdxp =
d3valdcl_get_tdxp(dval)
val wsxp =
d3valdcl_get_wsxp(dval)
//
#impltmp g_print$out<>() = out
//
in//let
(
prints
("D3VALDCL(",dpat,";",tdxp,";",wsxp,")"))
end(*let*)//end-of-[d3valdcl_fprint(out,dval)]

(* ****** ****** *)
//
#implfun
d3vardcl_fprint
  (out, dvar) = let
//
val dpid =
d3vardcl_get_dpid(dvar)
val vpid =
d3vardcl_get_vpid(dvar)
val sres =
d3vardcl_get_sres(dvar)
val dini =
d3vardcl_get_dini(dvar)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D3VARDCL(");
prints(dpid,";",vpid,";",sres,";",dini,")"))
end(*let*)//end-of-[d3vardcl_fprint(out,dvar)]
//
(* ****** ****** *)

#implfun
d3fundcl_fprint
  (out, dfun) = let
//
val dpid =
d3fundcl_get_dpid(dfun)
val farg =
d3fundcl_get_farg(dfun)
val sres =
d3fundcl_get_sres(dfun)
val tdxp =
d3fundcl_get_tdxp(dfun)
val wsxp =
d3fundcl_get_wsxp(dfun)
//
#impltmp g_print$out<>() = out
//
in//let
(
prints("D3FUNDCL(",dpid,";");
prints(farg,";",sres,";",tdxp,";",wsxp,")"))
end(*let*)//end-of-[d3fundcl_fprint(out,dfun)]

(* ****** ****** *)
(* ****** ****** *)

#implfun
d3parsed_fprint
  (out, dpar) = let
//
val
stadyn =
d3parsed_get_stadyn(dpar)
val
nerror =
d3parsed_get_nerror(dpar)
val
source =
d3parsed_get_source(dpar)
val
parsed =
d3parsed_get_parsed(dpar)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D3PARSED(");
prints
(stadyn,";",nerror,";",source,";",parsed,")"))
end (*let*) // end-of-[d3parsed_fprint(out,dpar)]

(* ****** ****** *)
(* ****** ****** *)

(* end of [ATS3/XATSOPT_srcgen2_DATS_dynexp3_print0.dats] *)
