(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2023 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue Dec 26 22:51:15 EST 2023
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
#include
"./../HATS/xatsopt_sats.hats"
#include
"./../HATS/xatsopt_dats.hats"
(* ****** ****** *)
#define
ATS_PACKNAME
"ATS3.XANADU.xatsopt-20220500"
(* ****** ****** *)
(* ****** ****** *)
#staload
_(*?*) = "./lexing0_print0.dats"
(* ****** ****** *)
#staload "./../SATS/lexing0.sats"
(* ****** ****** *)
#staload "./../SATS/dynexp4.sats"
(* ****** ****** *)
(* ****** ****** *)
#symload lctn with d4pat_get_lctn
#symload node with d4pat_get_node
(* ****** ****** *)
#symload lctn with d4exp_get_lctn
#symload node with d4exp_get_node
(* ****** ****** *)
#symload lctn with f4arg_get_lctn
#symload node with f4arg_get_node
(* ****** ****** *)
#symload lctn with d4gua_get_lctn
#symload lctn with d4gpt_get_lctn
#symload lctn with d4cls_get_lctn
#symload node with d4gua_get_node
#symload node with d4gpt_get_node
#symload node with d4cls_get_node
(* ****** ****** *)
#symload lctn with d4ecl_get_lctn
#symload node with d4ecl_get_node
(* ****** ****** *)
(* ****** ****** *)
//
#implfun
dvtck_fprint
(out, vtck) =
let
#impltmp
g_print$out<>() = out
in//let
case+ vtck of
|DVTCK(d2v1, t2p1, stp1) =>
(
print("DVTCK(");
prints(d2v1, ";", t2p1, ";", stp1, ")"))
end(*let*)//end-of-[dvtck_fprint(out, vtck)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#implfun
d4pat_fprint
(out, d4p0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
d4p0.node() of
//
|D4Pany() =>
(
 prints("D4Pany(",")"))
|D4Pvar(d2v) =>
(
 prints("D4Pvar(",d2v,")"))
//
|D4Pint(tok) =>
(
 prints("D4Pint(",tok,")"))
|D4Pbtf(sym) =>
(
 prints("D4Pbtf(",sym,")"))
|D4Pchr(tok) =>
(
 prints("D4Pchr(",tok,")"))
|D4Pflt(tok) =>
(
 prints("D4Pflt(",tok,")"))
|D4Pstr(tok) =>
(
 prints("D4Pstr(",tok,")"))
//
|D4Pcon(d2c) =>
(
 prints("D4Pcon(",d2c,")"))
//
(* ****** ****** *)
|
D4Pdapp
(d4f0,npf1,d4ps) =>
( print("D4Pdapp(")
; prints(d4f0,";",npf1,";",d4ps,")"))
//
(* ****** ****** *)
//
|
D4Pannot
(d4p1, s1e2, s2e2) =>
(
print("D4Pannot(");
prints(d4p1, ";", s1e2, ";", s2e2,")"))
//
(* ****** ****** *)
//
|D4Pt2pck
( d4p1 , t2p2 ) =>
(
 prints("D4Pt2pck(",d4p1,";",t2p2,")"))
//
(* ****** ****** *)
//
|D4Pnone0() => prints( "D4Pnone0(",")" )
|D4Pnone1(d3p1) => prints("D4Pnone1(",d3p1,")")
|D4Pnone2(d4p1) => prints("D4Pnone2(",d4p1,")")
//
(* ****** ****** *)
//
|D4Perrck // HX: generated by [tread34]
(lvl1(*err-level*),dpat) => prints("D4Perrck(",lvl1,";",dpat,")")
//
end (*let*) // end of [d4pat_fprint(out, d4p0)]
//
(* ****** ****** *)
(* ****** ****** *)

#implfun
d4exp_fprint
(out, d4e0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
d4e0.node() of
//
|D4Eint(tok) =>
(
 prints("D4Eint(",tok,")"))
|D4Ebtf(sym) =>
(
 prints("D4Ebtf(",sym,")"))
|D4Echr(tok) =>
(
 prints("D4Echr(",tok,")"))
|D4Eflt(tok) =>
(
 prints("D4Eflt(",tok,")"))
|D4Estr(tok) =>
(
 prints("D4Estr(",tok,")"))
//
(* ****** ****** *)
//
|D4Evar(d2v) =>
(
 prints("D4Evar(", d2v, ")"))
//
(* ****** ****** *)
//
|D4Econ(d2c) =>
(
 prints("D4Econ(", d2c, ")"))
|D4Ecst(d2c) =>
(
 prints("D4Ecst(", d2c, ")"))
//
(* ****** ****** *)
//
|D4Edvts
(d4e1, dvts) =>
(
prints
("D4Edvts(", d4e1, ";", dvts, ")"))
//
|D4Efarg
(d4e1, f4as) =>
(
prints
("D4Efarg(", d4e1, ";", f4as, ")"))
//
(* ****** ****** *)
//
|D4Edapp
(d4f0,npf1,d4es) =>
( print("D4Edapp(")
; prints(d4f0,";",npf1,";",d4es,")"))
//
(* ****** ****** *)
//
|D4Elet0
(dcls, d4e1) =>
(
prints("D4Elet0(",dcls,";",d4e1,")"))
//
(* ****** ****** *)
//
|D4Eift0
(d4e1
,dthn,dels,tenv) =>
(
print("D4Eift0(");
prints
( d4e1,";"
, dthn, ";", dels, ";", tenv, ")" ))
//
|
D4Ecas0
(tknd,d4e1,dcls) =>
( print("D4Ecas0(");
  prints(tknd,";",d4e1,";",dcls,")"))
//
(* ****** ****** *)
//
|D4Eseqn
(d4es, d4e1) =>
(
prints("D4Eseqn(",d4es,";",d4e1,")"))
//
(* ****** ****** *)
//
|D4Etup0
(npf1, d4es) =>
(
prints("D4Etup0(",npf1,";",d4es,")"))
|
D4Etup1
(tknd,npf1,d4es) =>
( print("D4Etup1(")
; prints(tknd,";",npf1,";",d4es,")"))
|
D4Ercd2
(tknd,npf1,ldes) =>
( print("D4Ercd2(")
; prints(tknd,";",npf1,";",ldes,")"))
//
(* ****** ****** *)
|
D4Elam0
(tknd,f4as
,sres,arrw
,body,d2vs,dvts) =>
( print("D4Elam0(")
; prints(tknd,";",f4as,";")
; prints(sres,";",arrw,";")
; prints(body,";",d2vs,";",dvts,")"))
//
|
D4Efix0
(tknd,fid0
,f4as,sres,arrw
,body,d2vs,dvts) =>
( print("D4Efix0(")
; prints(tknd,";",fid0,";")
; prints(f4as,";",sres,";",arrw,";")
; prints(body,";",d2vs,";",dvts,")"))
//
(* ****** ****** *)
//
|
D4Eflat
(   d4e1   ) =>
prints("D4Eflat(",d4e1,")") // left-val
//
(* ****** ****** *)
//
|
D4Eassgn
(d4el, d4er) =>
(
 prints("D4Eassgn(",d4el,";",d4er,")"))
//
(* ****** ****** *)
//
|
D4Eraise
(tknd, d4e1) =>
(
 prints("D4Eraise(",tknd,";",d4e1,")"))
//
(* ****** ****** *)
//
|D4Elabck
( d4e1 , lab2 ) =>
let
val
t2p1 = d4e1.styp() in
( print("D4Elabck(")
; prints( d4e1, ";",t2p1, ";",lab2,")"))
endlet // end of [ D4Elabck(d4e1, lab2) ]
//
|D4Et2pck
( d4e1 , t2p2 ) =>
let
val
t2p1 = d4e1.styp() in
( print("D4Et2pck(")
; prints( d4e1, ";",t2p1, ";",t2p2,")"))
endlet // end of [ D4Et2pck(d4e1, t2p2) ]
//
(* ****** ****** *)
//
|D4Ep2tck
( d4e1 , t2p2 ) =>
(
prints("D4Ep2tck(", d4e1, ";", t2p2,")"))
//
(* ****** ****** *)
//
|D4Elinex
( d4e1 , t2p2 ) =>
(
prints("D4Elinex(", d4e1, ";", t2p2,")"))
//
(* ****** ****** *)
//
|D4Edvtck
( d4e1 , tcks ) =>
(
prints("D4Edvtck(", d4e1, ";", tcks,")"))
//
(* ****** ****** *)
//
|D4Enone0() => prints( "D4Enone0(", ")" )
|D4Enone1(d3e1) => prints("D4Enone1(", d3e1, ")")
|D4Enone2(d4e1) => prints("D4Enone2(", d4e1, ")")
//
|D4Eerrck // HX: generated by [tread34]
(lvl1(*err-level*),dexp) => prints("D4Eerrck(",lvl1,";",dexp,")")
//
end (*let*) // end of [d4exp_fprint(out, d4e0)]

(* ****** ****** *)
(* ****** ****** *)
//
#implfun
f4arg_fprint
(out, farg) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
farg.node() of
|
F4ARGdapp
(npf1,d4ps) =>
prints
("F4ARGdapp(",npf1,";",d4ps,")")
|
F4ARGsapp
(s2vs,s2ps) =>
prints
("F4ARGsapp(",s2vs,";",s2ps,")")
|
F4ARGmets
(   s2es   ) => prints("F4ARGmets(",s2es,")")
(*
|
F4ARGsapq
(   s2vs   ) => prints("F4ARGsapq(",s2vs,")")
*)
//
end (*let*) // end of [f4arg_fprint(out,farg)]
//
(* ****** ****** *)
//
#implfun
d4gua_fprint
(out, dgua) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
dgua.node() of
|
D4GUAexp(d4e1) =>
prints("D4GUAexp(",d4e1,")")
|
D4GUAmat(d4e1,d4p2) =>
prints("D4GUAmat(",d4e1,";",d4p2,")")
//
end (*let*) // end of [d4gua_fprint(out,dgua)]
//
(* ****** ****** *)
//
#implfun
d4gpt_fprint
(out, dgpt) =
let
#impltmp
g_print$out<>() = out
in//let
case+
dgpt.node() of
|
D4GPTpat(d4p1) =>
prints("D4GPTpat(",d4p1,")")
|
D4GPTgua(d4p1,d4gs) =>
prints("D4GPTgua(",d4p1,";",d4gs,")")
end (*let*) // end of [d4gpt_fprint(out,dgpt)]
//
#implfun
d4cls_fprint
(out, dcls) =
let
//
#impltmp
g_print$out<>() = out
//
val darg =
(
  d4cls_get_darg(dcls))
val d2vs =
(
  d4cls_get_vars(dcls))
val dvts =
(
  d4cls_get_dvts(dcls))
//
in//let
case+
dcls.node() of
|
D4CLSgpt(dgpt) =>
(
prints("D4CLSgpt(", dgpt, ")"))
|
D4CLScls(d4g1,d4e2) =>
(
print("D4CLScls(");
prints
( d4g1, ";", d4e2, ";"
, darg, ";", d2vs, ";", dvts, ")"))
end (*let*) // end of [d4cls_fprint(out,dcls)]
//
(* ****** ****** *)
(* ****** ****** *)

#implfun
d4ecl_fprint
(out, dcl0) =
let
#impltmp
g_print$out<>() = out
in//let
//
case+
dcl0.node() of
//
|D4Cd3ecl(d3cl) =>
prints("D4Cd3ecl(",d3cl,")")
//
(* ****** ****** *)
//
|D4Clocal0(head, body) =>
(
prints("D4Clocal(",head,";",body,")"))
//
(* ****** ****** *)
//
|
D4Cinclude
( knd0, tknd
, gsrc, fopt, dopt ) =>
(
print("D4Cinclude(");
prints
(
knd0,";",
tknd,";",gsrc,";",fopt,";","...",")"))
//
(* ****** ****** *)
//
|
D4Cvaldclst
(  tknd, d4vs  ) =>
(
prints("D4Cvaldclst(",tknd,";",d4vs,")"))
|
D4Cvardclst
(  tknd, d4vs  ) =>
(
prints("D4Cvardclst(",tknd,";",d4vs,")"))
//
|
D4Cfundclst
(tknd
,tqas,d2cs,d4fs) =>
(
print("D4Cfundclst(");
prints(tknd,";",tqas,";",d2cs,";",d4fs,")"))
//
(* ****** ****** *)
//
|D4Cnone0() => prints( "D4Cnone0(", ")" )
|D4Cnone1(d3cl) => prints( "D4Cnone1(",d3cl,")" )
|D4Cnone2(d4cl) => prints( "D4Cnone2(",d4cl,")" )
//
(* ****** ****** *)
//
|
D4Cerrck // HX: generated by [tread01]
(lvl1(*err-level*),d4cl) => prints("D4Cerrck(",lvl1,";",d4cl,")")
//
end (*let*) // end of [d4ecl_fprint(out, dcl0)]

(* ****** ****** *)
(* ****** ****** *)
//
#implfun
d4valdcl_fprint
  (out, dval) = let
//
val dpat =
d4valdcl_get_dpat(dval)
val darg =
d4valdcl_get_darg(dval)
val tdxp =
d4valdcl_get_tdxp(dval)
val wsxp =
d4valdcl_get_wsxp(dval)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D4VALDCL(");
prints(dpat,";",darg,";",tdxp,";",wsxp,")"))
end(*let*)//end-of-[d4valdcl_fprint(out,dval)]
//
(* ****** ****** *)
//
#implfun
d4vardcl_fprint
  (out, dvar) = let
//
val dpid =
d4vardcl_get_dpid(dvar)
val vpid =
d4vardcl_get_vpid(dvar)
val sres =
d4vardcl_get_sres(dvar)
val dini =
d4vardcl_get_dini(dvar)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D4VARDCL(");
prints(dpid,";",vpid,";",sres,";",dini,")"))
end(*let*)//end-of-[d4vardcl_fprint(out,dvar)]
//
(* ****** ****** *)

#implfun
d4fundcl_fprint
  (out, dfun) = let
//
val dpid =
d4fundcl_get_dpid(dfun)
val farg =
d4fundcl_get_farg(dfun)
val sres =
d4fundcl_get_sres(dfun)
val tdxp =
d4fundcl_get_tdxp(dfun)
val wsxp =
d4fundcl_get_wsxp(dfun)
//
val d2vs =
d4fundcl_get_vars(dfun)
val dvts =
d4fundcl_get_dvts(dfun)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D4FUNDCL(");
prints(
dpid, ";", farg, ";", sres, ";");
prints(
tdxp, ";", wsxp, ";", d2vs, ";", dvts, ")"))
end(*let*)//end-of-[d4fundcl_fprint(out,dfun)]

(* ****** ****** *)
(* ****** ****** *)

#implfun
d4parsed_fprint
  (out, dpar) = let
//
val
stadyn =
d4parsed_get_stadyn(dpar)
val
nerror =
d4parsed_get_nerror(dpar)
val
source =
d4parsed_get_source(dpar)
val
parsed =
d4parsed_get_parsed(dpar)
//
#impltmp g_print$out<>() = out
//
in//let
(
print("D4PARSED(");
prints
(stadyn,";",nerror,";",source,";",parsed,")"))
end (*let*) // end-of-[d4parsed_fprint(out,dpar)]

(* ****** ****** *)
(* ****** ****** *)

(* end of [ATS3/XATSOPT_srcgen2_DATS_dynexp4_print0.dats] *)
